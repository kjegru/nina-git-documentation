{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to NINA's Git Documentation Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. (basics) key-terms.md # Glossary of simplified key terms. (basics) intro-to-git.md # How does Git work?. (basics) guides/ git-basics-guide.md # Working with Git from the command line. (basics) git-workflow-guide.md # The git workflow guide. (intermediate)","title":"Welcome to NINA's Git Documentation"},{"location":"#welcome-to-ninas-git-documentation","text":"","title":"Welcome to NINA's Git Documentation"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. (basics) key-terms.md # Glossary of simplified key terms. (basics) intro-to-git.md # How does Git work?. (basics) guides/ git-basics-guide.md # Working with Git from the command line. (basics) git-workflow-guide.md # The git workflow guide. (intermediate)","title":"Project layout"},{"location":"intro-to-git/","text":"Introduction to Git - The Basics What is Git? Git is like a time machine for your code. It keeps track of all changes you make to your files, allowing you to: - Save different versions of your work - Collaborate with others - Go back in time if something breaks Local vs Online Repositories Think of Git like this: Local Repository (Your Computer) Like working on documents saved on your computer Only you can see and work with these files Changes are saved locally You have full version history on your machine Online Repository (GitHub, GitLab, etc.) Like OneDrive/Dropbox for your code Others can see and work with your files Acts as a backup of your work Enables collaboration with team members How They Work Together You work on files locally Save (commit) changes on your computer Send (push) these changes to the online repository Others can download (pull) your changes Repeat! Common Workflow Download online or create local project ( git clone or git init ) Make changes to files Save changes ( git add and git commit ) connect to online project Share changes online ( git push ) Get others' changes ( git pull )","title":"Introduction to Git - The Basics"},{"location":"intro-to-git/#introduction-to-git-the-basics","text":"","title":"Introduction to Git - The Basics"},{"location":"intro-to-git/#what-is-git","text":"Git is like a time machine for your code. It keeps track of all changes you make to your files, allowing you to: - Save different versions of your work - Collaborate with others - Go back in time if something breaks","title":"What is Git?"},{"location":"intro-to-git/#local-vs-online-repositories","text":"Think of Git like this:","title":"Local vs Online Repositories"},{"location":"intro-to-git/#local-repository-your-computer","text":"Like working on documents saved on your computer Only you can see and work with these files Changes are saved locally You have full version history on your machine","title":"Local Repository (Your Computer)"},{"location":"intro-to-git/#online-repository-github-gitlab-etc","text":"Like OneDrive/Dropbox for your code Others can see and work with your files Acts as a backup of your work Enables collaboration with team members","title":"Online Repository (GitHub, GitLab, etc.)"},{"location":"intro-to-git/#how-they-work-together","text":"You work on files locally Save (commit) changes on your computer Send (push) these changes to the online repository Others can download (pull) your changes Repeat!","title":"How They Work Together"},{"location":"intro-to-git/#common-workflow","text":"Download online or create local project ( git clone or git init ) Make changes to files Save changes ( git add and git commit ) connect to online project Share changes online ( git push ) Get others' changes ( git pull )","title":"Common Workflow"},{"location":"key-terms/","text":"Key Terms Simplified Repository : A project folder that Git watches Clone : Copying a remote repository to your local machine. This is a download of the repository including Git tracking Stage : Preparing changes for a commit, like gathering items in a cart before checkout Commit : A snapshot of your changes (like saving a game) Push : Uploading local commits to the remote repository, similar to publishing updates to a shared document Pull : Downloading changes from the remote repository to your local one, like syncing an app to get the latest updates Master/Main Branch : The default primary branch in most repositories, often representing the main or production-ready version of your project. May be protected from direct merges and require pull-requests for changes Merge Conflict : When conflicting changes prevent a merge, just like when two people edit the same paragraph in a document. Often needs to be resolved manually HEAD : The current commit your repository is on. Think of it as a bookmark marking where you left off Stash : Temporarily shelving changes that you aren't ready to commit. These can be retrieved later Fork : A copy of someone else's repository that you make in your GitHub account to work on independently, like creating your own version of a shared document Pull Request : A request to merge changes from one branch or fork into another, often used to propose updates or improvements in collaborative projects Tag : A marker for a specific point in the history of your repository, often used for releases / versions Tracked Files : Files that Git is monitoring for changes. These can be unmodified, modified, or staged for commit. All files that have been previously committed or staged are tracked files. Untracked files are new files that Git doesn't yet monitor until you explicitly add them.","title":"Key terms"},{"location":"key-terms/#key-terms-simplified","text":"Repository : A project folder that Git watches Clone : Copying a remote repository to your local machine. This is a download of the repository including Git tracking Stage : Preparing changes for a commit, like gathering items in a cart before checkout Commit : A snapshot of your changes (like saving a game) Push : Uploading local commits to the remote repository, similar to publishing updates to a shared document Pull : Downloading changes from the remote repository to your local one, like syncing an app to get the latest updates Master/Main Branch : The default primary branch in most repositories, often representing the main or production-ready version of your project. May be protected from direct merges and require pull-requests for changes Merge Conflict : When conflicting changes prevent a merge, just like when two people edit the same paragraph in a document. Often needs to be resolved manually HEAD : The current commit your repository is on. Think of it as a bookmark marking where you left off Stash : Temporarily shelving changes that you aren't ready to commit. These can be retrieved later Fork : A copy of someone else's repository that you make in your GitHub account to work on independently, like creating your own version of a shared document Pull Request : A request to merge changes from one branch or fork into another, often used to propose updates or improvements in collaborative projects Tag : A marker for a specific point in the history of your repository, often used for releases / versions Tracked Files : Files that Git is monitoring for changes. These can be unmodified, modified, or staged for commit. All files that have been previously committed or staged are tracked files. Untracked files are new files that Git doesn't yet monitor until you explicitly add them.","title":"Key Terms Simplified"},{"location":"guides/git-basics-guide/","text":"Git Basics: A Beginner's Guide This guide will help you understand the basic Git commands you need to start version controlling your projects. Setting Up Git There are many ways to work with Git, as there are numerous programs available: RStudio : Integrated Git support for projects*. VS Code : Built-in Git tools and extensions. Standalone Tools : Many standalone Git clients are also available. E.g. Gitcraken Integrated when using one of the share NINA-servers like https://rstudio.nina.no. If using the Windows laptop Git has be installed using Firmaportal and searching for \"git 2\". However, this guide uses Git in the terminal, as it is a universal approach that works across all environments. The subcommand in the Git commands will match what you see in your chosen program anyway. First-time Setup Before you start using Git, you should set up your identity: git config --global user.name \"Your Name\" git config --global user.email \"your.email@example.com\" Basic Git Commands Creating a New Local Repository To start version controlling a project: # Navigate to your project folder cd your-project-folder # Initialize Git repository git init Working with Changes Checking Status Always start by checking what files have changed: git status Adding Files To prepare files for commit (staging): # Add a specific file git add filename.txt # Add multiple files git add file1.txt file2.txt # Add all changed files in the current directory git add . # Add all files across entire project and show the files that are added git add -Av # Add all files with a specific extension git add *.txt Committing Changes Save your staged changes: # Basic commit git commit -m \"Your commit message\" # Add and commit in one command (only for tracked files) git commit -am \"Your commit message\" Viewing Changes See what you've changed: # See unstaged changes git diff # See staged changes git diff --staged # See commit history git log Working with Remote Repositories There are two ways to get a connect to an existing remote repository: Cloning an Existing Remote Repository This is done when the remote repostory has a lot of files. To get a copy of an existing Git repository: # Clone a repository from GitHub/GitLab etc. git clone https://github.com/username/repository-name.git # Clone to a specific folder git clone https://github.com/username/repository-name.git my-folder Adding a Remote Repository Connecting a local repository to a remote empty repository: git remote add origin https://github.com/username/repository-name.git Pushing Changes Send your commits to the remote repository: # First time push from a new branch git push -u origin main # Subsequent pushes git push Getting Updates Remember: Always pull before you push to avoid conflicts! Get and integrate changes from the remote repository: # Fetch changes without merging git fetch # Fetch and merge changes git pull Common Workflows Starting a New Project # Create a new directory mkdir my-project cd my-project # Initialize Git git init # Create some files touch README.md # Add and commit files git add . git commit -m \"Initial commit\" # Connect to remote (if using GitHub/GitLab) git remote add origin https://github.com/username/my-project.git git push -u origin main Working on an Existing Project # Clone the repository git clone https://github.com/username/project.git # Make changes to files # ... # Check status git status # Add changes git add . # Commit changes git commit -m \"Description of changes\" # Push changes git push Best Practices Commit Messages Use clear, descriptive commit messages Start with a verb (Add, Update, Fix, etc.) Keep messages concise but informative Frequent Commits Commit small, logical changes Don't wait until you have many changes Each commit should represent one logical change Pull Before Push Always pull before pushing to avoid conflicts Handle any conflicts locally before pushing Check Status Regularly Use git status frequently Verify what files are staged before committing Common Issues and Solutions Undoing Changes # Undo unstaged changes to a file git checkout -- filename # Unstage a file (but keep changes) git reset HEAD filename # Undo last commit (keep changes staged) git reset --soft HEAD^ # Undo last commit and all changes git reset --hard HEAD^ Fixing Wrong Commit Message # Fix last commit message git commit --amend -m \"New message\" Handling Merge Conflicts When you get a merge conflict: 1. Open the conflicted files 2. Look for the conflict markers (<<<<<<, =======, >>>>>>>) 3. Edit the files to resolve conflicts 4. Add the resolved files 5. Complete the merge with commit # After resolving conflicts git add . git commit -m \"Resolve merge conflicts\"","title":"Git Basics: A Beginner's Guide"},{"location":"guides/git-basics-guide/#git-basics-a-beginners-guide","text":"This guide will help you understand the basic Git commands you need to start version controlling your projects.","title":"Git Basics: A Beginner's Guide"},{"location":"guides/git-basics-guide/#setting-up-git","text":"There are many ways to work with Git, as there are numerous programs available: RStudio : Integrated Git support for projects*. VS Code : Built-in Git tools and extensions. Standalone Tools : Many standalone Git clients are also available. E.g. Gitcraken Integrated when using one of the share NINA-servers like https://rstudio.nina.no. If using the Windows laptop Git has be installed using Firmaportal and searching for \"git 2\". However, this guide uses Git in the terminal, as it is a universal approach that works across all environments. The subcommand in the Git commands will match what you see in your chosen program anyway.","title":"Setting Up Git"},{"location":"guides/git-basics-guide/#first-time-setup","text":"Before you start using Git, you should set up your identity: git config --global user.name \"Your Name\" git config --global user.email \"your.email@example.com\"","title":"First-time Setup"},{"location":"guides/git-basics-guide/#basic-git-commands","text":"","title":"Basic Git Commands"},{"location":"guides/git-basics-guide/#creating-a-new-local-repository","text":"To start version controlling a project: # Navigate to your project folder cd your-project-folder # Initialize Git repository git init","title":"Creating a New Local Repository"},{"location":"guides/git-basics-guide/#working-with-changes","text":"","title":"Working with Changes"},{"location":"guides/git-basics-guide/#checking-status","text":"Always start by checking what files have changed: git status","title":"Checking Status"},{"location":"guides/git-basics-guide/#adding-files","text":"To prepare files for commit (staging): # Add a specific file git add filename.txt # Add multiple files git add file1.txt file2.txt # Add all changed files in the current directory git add . # Add all files across entire project and show the files that are added git add -Av # Add all files with a specific extension git add *.txt","title":"Adding Files"},{"location":"guides/git-basics-guide/#committing-changes","text":"Save your staged changes: # Basic commit git commit -m \"Your commit message\" # Add and commit in one command (only for tracked files) git commit -am \"Your commit message\"","title":"Committing Changes"},{"location":"guides/git-basics-guide/#viewing-changes","text":"See what you've changed: # See unstaged changes git diff # See staged changes git diff --staged # See commit history git log","title":"Viewing Changes"},{"location":"guides/git-basics-guide/#working-with-remote-repositories","text":"There are two ways to get a connect to an existing remote repository:","title":"Working with Remote Repositories"},{"location":"guides/git-basics-guide/#cloning-an-existing-remote-repository","text":"This is done when the remote repostory has a lot of files. To get a copy of an existing Git repository: # Clone a repository from GitHub/GitLab etc. git clone https://github.com/username/repository-name.git # Clone to a specific folder git clone https://github.com/username/repository-name.git my-folder","title":"Cloning an Existing Remote Repository"},{"location":"guides/git-basics-guide/#adding-a-remote-repository","text":"Connecting a local repository to a remote empty repository: git remote add origin https://github.com/username/repository-name.git","title":"Adding a Remote Repository"},{"location":"guides/git-basics-guide/#pushing-changes","text":"Send your commits to the remote repository: # First time push from a new branch git push -u origin main # Subsequent pushes git push","title":"Pushing Changes"},{"location":"guides/git-basics-guide/#getting-updates","text":"Remember: Always pull before you push to avoid conflicts! Get and integrate changes from the remote repository: # Fetch changes without merging git fetch # Fetch and merge changes git pull","title":"Getting Updates"},{"location":"guides/git-basics-guide/#common-workflows","text":"","title":"Common Workflows"},{"location":"guides/git-basics-guide/#starting-a-new-project","text":"# Create a new directory mkdir my-project cd my-project # Initialize Git git init # Create some files touch README.md # Add and commit files git add . git commit -m \"Initial commit\" # Connect to remote (if using GitHub/GitLab) git remote add origin https://github.com/username/my-project.git git push -u origin main","title":"Starting a New Project"},{"location":"guides/git-basics-guide/#working-on-an-existing-project","text":"# Clone the repository git clone https://github.com/username/project.git # Make changes to files # ... # Check status git status # Add changes git add . # Commit changes git commit -m \"Description of changes\" # Push changes git push","title":"Working on an Existing Project"},{"location":"guides/git-basics-guide/#best-practices","text":"Commit Messages Use clear, descriptive commit messages Start with a verb (Add, Update, Fix, etc.) Keep messages concise but informative Frequent Commits Commit small, logical changes Don't wait until you have many changes Each commit should represent one logical change Pull Before Push Always pull before pushing to avoid conflicts Handle any conflicts locally before pushing Check Status Regularly Use git status frequently Verify what files are staged before committing","title":"Best Practices"},{"location":"guides/git-basics-guide/#common-issues-and-solutions","text":"","title":"Common Issues and Solutions"},{"location":"guides/git-basics-guide/#undoing-changes","text":"# Undo unstaged changes to a file git checkout -- filename # Unstage a file (but keep changes) git reset HEAD filename # Undo last commit (keep changes staged) git reset --soft HEAD^ # Undo last commit and all changes git reset --hard HEAD^","title":"Undoing Changes"},{"location":"guides/git-basics-guide/#fixing-wrong-commit-message","text":"# Fix last commit message git commit --amend -m \"New message\"","title":"Fixing Wrong Commit Message"},{"location":"guides/git-basics-guide/#handling-merge-conflicts","text":"When you get a merge conflict: 1. Open the conflicted files 2. Look for the conflict markers (<<<<<<, =======, >>>>>>>) 3. Edit the files to resolve conflicts 4. Add the resolved files 5. Complete the merge with commit # After resolving conflicts git add . git commit -m \"Resolve merge conflicts\"","title":"Handling Merge Conflicts"},{"location":"guides/git-workflow-guide/","text":"Git Workflow Guide This document outlines the branching strategy and workflow used in this project to ensure stability, efficient development, and smooth deployment to production and testing environments. Branch Overview production : Protected production branch that deploys directly to production servers. Only accepts PRs from main . main : Protected source of truth, representing the latest stable and approved state of the project. test : Protected integration testing branch that deploys to test servers. dev : Development branches for individual features ( feat/ ) or patches ( fix/ ). While production and main may often contain similar code, they serve different purposes. The main branch is the latest stable code that has been tested, while the production branch is the code that is currently live. This separation allows for a more controlled deployment process, ensuring that only thoroughly reviewed and approved code reaches production. Resetting the test branch from main after patches have been accepted or declined is a good practice in your workflow. This approach ensures that the test branch remains a clean and accurate reflection of the current state of main plus any new patches that are actively under testing. Caution: Force-pushing to a shared branch like test can affect other developers working on it. Ensure that all team members are aware of this practice and have committed or stashed their work before the reset. Branching Strategy 1. production Branch Purpose : Production-ready code only Protection : Requires PR and approvals from main Deploys : Automatically to production servers Rules : No direct commits, PR only 2. main Branch Purpose : Source of truth for stable code Protection : Requires PR and approvals Updates : Accepts PRs from test after successful testing Rules : No direct commits, PR only 3. test Branch Purpose : Integration testing environment Protection : Requires PR from feature/fix branches Deploys : Automatically to test servers Rules : PR required, automated tests must pass 4. Feature and Fix Branches Purpose : Individual development work Naming : Features: feat/feature-name Fixes: fix/issue-name Source : Always branch from test Merge : Back to test via PR Workflow Steps 1. Starting New Work # Update test branch git checkout test git pull origin test # Create new feature branch git checkout -b feat/feature-name # or for fixes git checkout -b fix/issue-name 2. Development Process # Regular commits to your branch git add . git commit -m \"feat: descriptive message\" # Keep branch updated with test git checkout test git pull origin test git checkout feat/feature-name git rebase test 3. Creating Pull Requests Feature \u2192 Test Create PR from your feature branch to test Ensure all tests pass Get code review approval Merge using rebase strategy Test \u2192 Main After testing in test environment Create PR from test to main Requires additional review Merge using rebase strategy Main \u2192 Production Create PR from main to production Final review and approval Merge using rebase strategy Best Practices Commit Messages Use conventional commits format: feat: add new feature fix: resolve issue docs: update documentation refactor: improve code structure Branch Management Keep branches short-lived Delete branches after merging Regularly rebase with test Code Review Required for all PRs Check for: Code quality Test coverage Documentation updates Security considerations Deployment Verification Verify deployments in test environment Run full test suite before production merge Monitor deployments for issues Common Commands # Create new feature branch git checkout -b feat/feature-name # Update branch with latest test changes git checkout test git pull origin test git checkout feat/feature-name git rebase test # Force push after rebase (if needed) git push origin feat/feature-name --force-with-lease # Delete local branch after merge git branch -d feat/feature-name # Delete remote branch git push origin --delete feat/feature-name","title":"Git Workflow Guide"},{"location":"guides/git-workflow-guide/#git-workflow-guide","text":"This document outlines the branching strategy and workflow used in this project to ensure stability, efficient development, and smooth deployment to production and testing environments.","title":"Git Workflow Guide"},{"location":"guides/git-workflow-guide/#branch-overview","text":"production : Protected production branch that deploys directly to production servers. Only accepts PRs from main . main : Protected source of truth, representing the latest stable and approved state of the project. test : Protected integration testing branch that deploys to test servers. dev : Development branches for individual features ( feat/ ) or patches ( fix/ ). While production and main may often contain similar code, they serve different purposes. The main branch is the latest stable code that has been tested, while the production branch is the code that is currently live. This separation allows for a more controlled deployment process, ensuring that only thoroughly reviewed and approved code reaches production. Resetting the test branch from main after patches have been accepted or declined is a good practice in your workflow. This approach ensures that the test branch remains a clean and accurate reflection of the current state of main plus any new patches that are actively under testing. Caution: Force-pushing to a shared branch like test can affect other developers working on it. Ensure that all team members are aware of this practice and have committed or stashed their work before the reset.","title":"Branch Overview"},{"location":"guides/git-workflow-guide/#branching-strategy","text":"","title":"Branching Strategy"},{"location":"guides/git-workflow-guide/#1-production-branch","text":"Purpose : Production-ready code only Protection : Requires PR and approvals from main Deploys : Automatically to production servers Rules : No direct commits, PR only","title":"1. production Branch"},{"location":"guides/git-workflow-guide/#2-main-branch","text":"Purpose : Source of truth for stable code Protection : Requires PR and approvals Updates : Accepts PRs from test after successful testing Rules : No direct commits, PR only","title":"2. main Branch"},{"location":"guides/git-workflow-guide/#3-test-branch","text":"Purpose : Integration testing environment Protection : Requires PR from feature/fix branches Deploys : Automatically to test servers Rules : PR required, automated tests must pass","title":"3. test Branch"},{"location":"guides/git-workflow-guide/#4-feature-and-fix-branches","text":"Purpose : Individual development work Naming : Features: feat/feature-name Fixes: fix/issue-name Source : Always branch from test Merge : Back to test via PR","title":"4. Feature and Fix Branches"},{"location":"guides/git-workflow-guide/#workflow-steps","text":"","title":"Workflow Steps"},{"location":"guides/git-workflow-guide/#1-starting-new-work","text":"# Update test branch git checkout test git pull origin test # Create new feature branch git checkout -b feat/feature-name # or for fixes git checkout -b fix/issue-name","title":"1. Starting New Work"},{"location":"guides/git-workflow-guide/#2-development-process","text":"# Regular commits to your branch git add . git commit -m \"feat: descriptive message\" # Keep branch updated with test git checkout test git pull origin test git checkout feat/feature-name git rebase test","title":"2. Development Process"},{"location":"guides/git-workflow-guide/#3-creating-pull-requests","text":"Feature \u2192 Test Create PR from your feature branch to test Ensure all tests pass Get code review approval Merge using rebase strategy Test \u2192 Main After testing in test environment Create PR from test to main Requires additional review Merge using rebase strategy Main \u2192 Production Create PR from main to production Final review and approval Merge using rebase strategy","title":"3. Creating Pull Requests"},{"location":"guides/git-workflow-guide/#best-practices","text":"Commit Messages Use conventional commits format: feat: add new feature fix: resolve issue docs: update documentation refactor: improve code structure Branch Management Keep branches short-lived Delete branches after merging Regularly rebase with test Code Review Required for all PRs Check for: Code quality Test coverage Documentation updates Security considerations Deployment Verification Verify deployments in test environment Run full test suite before production merge Monitor deployments for issues","title":"Best Practices"},{"location":"guides/git-workflow-guide/#common-commands","text":"# Create new feature branch git checkout -b feat/feature-name # Update branch with latest test changes git checkout test git pull origin test git checkout feat/feature-name git rebase test # Force push after rebase (if needed) git push origin feat/feature-name --force-with-lease # Delete local branch after merge git branch -d feat/feature-name # Delete remote branch git push origin --delete feat/feature-name","title":"Common Commands"}]}